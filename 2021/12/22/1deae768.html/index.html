<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="GicLYNNqJJ-XBSPlE8Pz-ZwGf2ElS_d_VRcEsQServ4"><meta name="google-site-verification" content="rn4dOdASKHwgOgBKFwN8nAB0OlnuC_pNB8qLDnMyPpc"><meta name="baidu-site-verification" content="093lY4ziMu"><meta name="baidu-site-verification" content="code-W4A0ktcwoi"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="description" content="nojsja 个人博客"><meta name="keyword" content=""><link rel="shortcut icon" href="/blogs/img/favicon.ico"><link href="/blogs/fonts/fontawesome-webfont.woff2?v=4.3.0" rel="preload" as="font" crossorigin><link href="https://www.google-analytics.com" rel="preconnect" crossorigin><link href="http://busuanzi.ibruce.info" rel="preconnect" crossorigin><link href="http://nojsja.gitee.io" rel="preconnect" crossorigin><title>Electron 进程管理工具开发日记3：进程池负载均衡、智能启停 - nojsja | Blog</title><link rel="canonical" href="https://nojsja.github.io/blogs/blogs/2021/12/22/1deae768.html/"><link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.2/css/bootstrap.min.css" rel="stylesheet"><link rel="stylesheet" href="/blogs/css/dusign-light.css"><link rel="stylesheet" href="/blogs/css/github-markdown.min.css"><style>.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}@media (max-width:767px){.markdown-body{padding:15px}}</style><link rel="stylesheet" href="/blogs/css/widget.css"><link rel="stylesheet" href="/blogs/css/fonts.googleapis.css"><link rel="stylesheet" href="/blogs/css/font-awesome.min.css"><script>function async(e,t,a,n){var c=document.head||document.getElementsByTagName("head")[0]||document.documentElement,d=document,r=a||"script",s=d.createElement(r),l=d.getElementsByTagName(r)[0];switch(n=["async","defer"].includes(n)?n:!!n,r){case"script":s.src=e,n&&(s[n]=!0);break;case"link":s.type="text/css",s.href=e,s.rel="stylesheet";break;default:s.src=e}t&&(s.readyState?s.onreadystatechange=function(e){"loaded"!=s.readyState&&"complete"!=s.readyState||(s.onreadystatechange=null,t(null,e)())}:s.onload=function(e){t(null,e)}),l.parentNode.insertBefore(s,c.firstChild)}</script><script>function sendXMLHttpRequest(e){var t=e.url,n=(e.method||"get").toUpperCase(),s=e.callback,a=!("async"in e)||!!e.async,c=null;t&&((c=window.XMLHttpRequest?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP")).open(n,t,a),c.onreadystatechange=function(){4===this.readyState&&(s&&s(this.responseText),c.onreadystatechange=null)},c.send(null))}</script><script>var fnDebounce=function(n,l){var t=null;return function(){return t?Date.now()-t>=l?(t=null,n.apply(this,[].slice.call(arguments))):void(t=Date.now()):t=Date.now()}},fnThrottle=function(n,l){var t=null;return function(){return t?Date.now()-t>=l?(t=null,n.apply(this,[].slice.call(arguments))):void 0:t=Date.now()}}</script><script>"IntersectionObserver"in window&&"IntersectionObserverEntry"in window&&"intersectionRatio"in window.IntersectionObserverEntry.prototype?"isIntersecting"in window.IntersectionObserverEntry.prototype||Object.defineProperty(window.IntersectionObserverEntry.prototype,"isIntersecting",{get:function(){return this.intersectionRatio>0}}):sendXMLHttpRequest({url:"/blogs/js/intersection-observer.js",async:!1,method:"get",callback:function(txt){eval(txt)}})</script><script src="/blogs/js/buttons.js" async defer></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blogs/atom.xml" title="nojsja" type="application/atom+xml">
</head><body><style type="text/css">header.intro-header{background-image:linear-gradient(rgba(0,0,0,.3),rgba(0,0,0,.3)),url(https://nojsja.gitee.io/static-resources/images/hexo/article_header/article_header.jpg)}</style><header class="intro-header"><div id="signature"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/blogs/tags/#node" title="node">node</a> <a class="tag" href="/blogs/tags/#electron" title="electron">electron</a> <a class="tag" href="/blogs/tags/#process" title="process">process</a></div><h1>Electron 进程管理工具开发日记3：进程池负载均衡、智能启停</h1><h2 class="subheading">Electron process management tool dev diary3: process pool load balancing, smart sleep and wake up</h2><span class="meta"><span class="post-description"><i class="fa fa-user" aria-hidden="true"></i> nojsja </span><span class="post-description"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-22</span></span><div class="blank_box"></div><span class="meta">字数：<span class="post-count">7.8k</span>丨 阅读时间：<span class="post-count">33</span> 分钟</span><div class="blank_box"></div></div></div></div></div></div><div class="waveWrapper"><div class="wave wave_before" style="background-image:url(/blogs/img/wave-light.png)"></div><div class="wave wave_after" style="background-image:url(/blogs/img/wave-light.png)"></div></div></header><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/blogs/">nojsja</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/blogs/">首页</a></li><li><a href="/blogs/about/">关于</a></li><li><a href="/blogs/archive/">时间轴</a></li><li><a href="/blogs/categories/">目录</a></li><li><a href="/blogs/tags/">标签</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout((function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")}),400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style>.table-responsive{border:none!important}</style><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container markdown-body"><blockquote><p>文中实现的部分工具方法正处于早期/测试阶段，仍在持续优化中，仅供参考…</p></blockquote><blockquote><p>在 Ubuntu20.04 上进行开发/测试，可用于 Electron 项目，测试版本：Electron@8.2.0 / 9.3.5</p></blockquote><h3 id="Contents">Contents</h3><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">├── Contents (you are here!)</span><br><span class="line">│</span><br><span class="line">├── I. 前言</span><br><span class="line">├── II. 架构图</span><br><span class="line">│</span><br><span class="line">├── III.electron-re 可以用来做什么？</span><br><span class="line">│   ├── 1) 用于 Electron 应用</span><br><span class="line">│   └── 2) 用于 Electron/Nodejs 应用</span><br><span class="line">│</span><br><span class="line">├── IV. UI 功能介绍</span><br><span class="line">│   ├── 主界面</span><br><span class="line">│   ├── 功能1：Kill 进程</span><br><span class="line">│   ├── 功能2：一键开启 DevTools</span><br><span class="line">│   ├── 功能3：查看进程日志</span><br><span class="line">│   ├── 功能4：查看进程 CPU/Memory 占用趋势</span><br><span class="line">│   └── 功能5：查看 MessageChannel 请求发送日志</span><br><span class="line">│</span><br><span class="line">├── V. 新特性：进程池负载均衡</span><br><span class="line">│   ├── 关于负载均衡</span><br><span class="line">│   ├── 负载均衡策略说明</span><br><span class="line">│   ├── 负载均衡策略的简易实现</span><br><span class="line">│   ├── 负载均衡器的实现</span><br><span class="line">│   └── 进程池配合 LoadBalancer 来实现负载均衡</span><br><span class="line">│</span><br><span class="line">├── VI. 新特性：子进程智能启停</span><br><span class="line">│   ├── 使进程休眠的各种方式</span><br><span class="line">│   ├── 生命周期 LifeCycle 的实现</span><br><span class="line">│   └── 进程互斥锁的雏形</span><br><span class="line">│</span><br><span class="line">├── VII. 存在的已知问题</span><br><span class="line">├── VIII. Next To Do</span><br><span class="line">│</span><br><span class="line">├── IX. 几个实际使用示例</span><br><span class="line">│   ├── 1) Service/MessageChannel 使用示例</span><br><span class="line">│   ├── 2) 一个实际用于生产项目的例子</span><br><span class="line">│   ├── 3) ChildProcessPool/ProcessHost 使用示例</span><br><span class="line">│   ├── 3) <span class="built_in">test</span> 测试目录示例</span><br><span class="line">│   └── 4) github README 说明</span><br><span class="line">│</span><br></pre></td></tr></table></figure><h3 id="I-前言">I. 前言</h3><hr><p>之前在做 Electron 应用开发的时候，写了个 Electron 进程管理工具 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/electron-re">electron-re</a>，支持 Electron/Node 多进程管理、service 模拟、进程实时监控(UI功能)、Node.js 进程池等特性。已经发布为npm组件，可以直接安装(最新特性还没发布到线上，需要再进行测试)：</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/electron-re">&gt;&gt; github地址</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$: npm install electron-re --save</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$: yarn add electron-re</span><br></pre></td></tr></table></figure><p>本主题前面两篇文章：</p><ol><li><a target="_blank" rel="noopener" href="https://nojsja.gitee.io/blogs/2020/12/08/6d582478.html/">《Electron/Node多进程工具开发日记》</a> 描述了<code>electron-re</code>的开发背景、针对的问题场景以及详细的使用方法。</li><li><a target="_blank" rel="noopener" href="https://nojsja.gitee.io/blogs/2020/12/18/927d467e.html/">《Electron多进程工具开发日记2》</a> 介绍了新特性 “多进程管理 UI” 的开发和使用相关。UI 界面基于 <code>electron-re</code> 已有的 <code>BrowserService/MessageChannel</code> 和 <code>ChildProcessPool/ProcessHost</code> 基础架构驱动，使用 React17 / Babel7 开发。</li></ol><p>这篇文章主要是描述最近支持的进程池模块新特性 - “进程池负载均衡” 和 “子进程智能启停”，以及相关的基本实现原理。同时提出自己遇到的一些问题，以及对这些问题的思考、解决方案，对之后版本迭代的一些想法等等。</p><h3 id="II-electron-re架构图">II. electron-re架构图</h3><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/electron-re_arch.png" alt="archtecture"></p><ul><li><strong>Electron Core</strong>：Electron 应用的一系列核心功能，包含了应用的主进程、渲染进程、窗口等等(Electron 自带)。</li><li><strong>BrowserWindow</strong>：渲染窗口进程，一般用于UI渲染 (Electron 自带)。</li><li><strong>ProcessManager</strong>：进程管理器，负责进程占用资源采集、异步刷新UI、响应和发出各种进程管理信号，作为一个观察者对象给其它模块和UI提供服务 (electron-re 引入)。</li><li><strong>MessageChannel</strong>：适用于主进程、渲染进程、Service 进程的消息发送工具，基于原生 IPC 封装，主要服务于 BrowserService，也可替代原生的 IPC 通信方法 (electron-re 引入)。</li><li><strong>ChildProcess</strong>：由 <code>child_process.fork</code> 方法生成的子进程，不过以装饰器的方式为其添加了简单的进程休眠和唤醒逻辑 (electron-re 引入)。</li><li><strong>ProcessHost</strong>：配合进程池使用的工具，我称它为 “进程事务中心”，封装了 <code>process.send / process.on</code> 基本逻辑，提供了 Promise 的调用方式让 主进程/子进程 之间 IPC 消息通信更简单 (electron-re 引入)。</li><li><strong>LoadBalancer</strong>：服务于进程池的负载均衡器。</li><li><strong>LifeCycle</strong>：服务于进程池的生命周期。</li><li><strong>ChildProcessPool</strong>：基于 Node.js - <code>child_process.fork</code> 方法实现的进程池，内部管理多个 ChildProcess 实例对象，支持自定义负载均衡策略、子进程智能启停、子进程异常退出后自动重启等特性 (electron-re 引入)。</li><li><strong>BrowserService</strong>：基于 BrowserWindow 实现的 Service 进程，可以看成是一个运行在后台的隐藏渲染窗口进程，允许 Node 注入，不过仅支持 <code>CommonJs</code> 规范。</li></ul><h3 id="III-electron-re-可以用来做什么？">III. electron-re 可以用来做什么？</h3><hr><h4 id="1-用于Electron应用">1. 用于Electron应用</h4><ul><li><code>BrowserService</code></li><li><code>MessageChannel</code></li></ul><p>在 Electron 的一些“最佳实践”中，建议将占用cpu的代码放到渲染过程中而不是直接放在主过程中，这里先看下 chromium 的架构图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/chromium.jpg" alt="archtecture"></p><p>每个渲染进程都有一个全局对象 RenderProcess，用来管理与父浏览器进程的通信，同时维护着一份全局状态。浏览器进程为每个渲染进程维护一个 RenderProcessHost 对象，用来管理浏览器状态和与渲染进程的通信。浏览器进程和渲染进程使用 Chromium 的 IPC 系统进行通信。在 chromium 中，页面渲染时，UI进程需要和 main process 不断的进行 IPC 同步，若此时 main process 忙，则 UIprocess 就会在 IPC 时阻塞。所以如果主进程持续进行消耗 CPU 时间的任务或阻塞同步 IO 的任务的话，就会在一定程度上阻塞，从而影响主进程和各个渲染进程之间的 IPC 通信，IPC 通信有延迟或是受阻，渲染进程窗口就会卡顿掉帧，严重的话甚至会卡住不动。</p><p>因此 <code>electron-re</code> 在 Electron 已有的 <code>Main Process</code> 主进程 和 <code>Renderer Process</code> 渲染进程逻辑的基础上独立出一个单独的 <code>Service</code> 概念。<code>Service</code>即不需要显示界面的后台进程，它不参与 UI 交互，单独为主进程或其它渲染进程提供服务，它的底层实现为一个允许 <code>node注入</code> 和 <code>remote调用</code> 的 <strong>隐藏渲染窗口进程</strong>。</p><p>这样就可以将代码中耗费 cpu 的操作(比如文件上传中维护一个数千个上传任务的队列)编写成一个单独的js文件，然后使用 <code>BrowserService</code> 构造函数以这个 js 文件的地址 <code>path</code> 为参数构造一个 <code>Service</code> 实例，从而将他们从主进程中分离。如果你说那这部分耗费 cpu 的操作直接放到渲染窗口进程可以嘛？这其实取决于项目自身的架构设计，以及对进程之间数据传输性能损耗和传输时间等各方面的权衡，创建一个 <code>Service</code> 的简单示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserService &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron-re&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myServcie = <span class="keyword">new</span> BrowserService(<span class="string">&#x27;app&#x27;</span>, path.join(__dirname, <span class="string">&#x27;path/to/app.service.js&#x27;</span>));</span><br></pre></td></tr></table></figure><p>如果使用了 <code>BrowserService</code> 的话，要想在主进程、渲染进程、service 进程之间相互发送消息就要使用 <code>electron-re</code> 提供的 <code>MessageChannel</code> 通信工具，它的接口设计跟 Electron 内建的<code>IPC</code>基本一致，底层也是基于原生的 <code>IPC</code> 异步通信原理来实现的，简单示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---- main.js ---- */</span></span><br><span class="line"><span class="keyword">const</span> &#123; BrowserService &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron-re&#x27;</span>);</span><br><span class="line"><span class="comment">// 主进程中向一个 service &#x27;app&#x27; 发送消息</span></span><br><span class="line">MessageChannel.send(<span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;channel1&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;test1&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="2-用于-Electron-Nodejs-应用">2. 用于 Electron/Nodejs 应用</h4><ul><li><code>ChildProcessPool</code></li><li><code>ProcessHost</code></li></ul><p>此外，如果要创建一些不依赖于 Electron 运行时的子进程（相关参考nodejs <code>child_process</code>），可以使用 <code>electron-re</code> 提供的专门为 nodejs 运行时编写的进程池 <code>ChildProcessPool</code> 。因为创建进程本身所需的开销很大，使用进程池来重复利用已经创建了的子进程，将多进程架构带来的性能效益最大化，简单示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* --- 主进程中 --- */</span></span><br><span class="line"><span class="keyword">const</span> &#123; ChildProcessPool, LoadBalancer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron-re&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = <span class="keyword">new</span> ChildProcessPool(&#123;</span><br><span class="line">  <span class="attr">path</span>: path.join(app.getAppPath(), <span class="string">&#x27;app/services/child.js&#x27;</span>), <span class="comment">// 子进程执行文件路径</span></span><br><span class="line">  <span class="attr">max</span>: <span class="number">3</span>, <span class="comment">// 最大进程数</span></span><br><span class="line">  <span class="attr">strategy</span>: LoadBalancer.ALGORITHM.WEIGHTS, <span class="comment">// 负载均衡策略 - 权重</span></span><br><span class="line">  <span class="attr">weights</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment">// 权重分配</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool</span><br><span class="line">  .send(<span class="string">&#x27;sync-work&#x27;</span>, params)</span><br><span class="line">  .then(<span class="function"><span class="params">rsp</span> =&gt;</span> <span class="built_in">console</span>.log(rsp));</span><br></pre></td></tr></table></figure><p>一般情况下，在我们的子进程执行文件中，为了在主进程和子进程之间同步数据，可以使用 <code>process.send('channel', params)</code> 和 <code>process.on('channel', function)</code> 的方式实现(前提是进程以以 <code>fork</code> 方式创建或者手动开启了 <code>IPC</code> 通信)。但是这样在处理业务逻辑的同时也强迫我们去关注进程之间的通信，你需要知道子进程什么时候能处理完毕，然后再使用<code>process.send</code>再将数据返回主进程，使用方式繁琐。</p><p><code>electron-re</code> 引入了 <code>ProcessHost</code> 的概念，我称之为&quot;进程事务中心&quot;。实际使用时在子进程执行文件中只需要将各个任务函数通过 <code>ProcessHost.registry('task-name', function)</code> 注册成多个被监听的事务，然后配合进程池的 <code>ChildProcessPool.send('task-name', params)</code> 来触发子进程事务逻辑的调用即可，<code>ChildProcessPool.send()</code> 同时会返回一个 Promise 实例以便获取回调数据，简单示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* --- 子进程中 --- */</span></span><br><span class="line"><span class="keyword">const</span> &#123; ProcessHost &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron-re&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ProcessHost</span><br><span class="line">  .registry(<span class="string">&#x27;sync-work&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&#x27;task-value&#x27;</span> &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">  .registry(<span class="string">&#x27;async-work&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(params.url);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="IV-UI-功能介绍">IV. UI 功能介绍</h3><hr><p>UI 功能基于 <code>electron-re</code> 基础架构开发，它通过异步 IPC 和主进程的 <code>ProcessManager</code> 进行通信，实时刷新进程状态。操作者可以通过 UI 手动 Kill 进程、查看进程 console 数据、查看进程数 CPU/Memory 占用趋势以及查看 <code>MessageChannel</code> 工具的请求发送记录。</p><h4 id="主界面">主界面</h4><blockquote><p>UI参考 electron-process-manager 设计</p></blockquote><p>预览图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/process-manager.main.png" alt="process-manager.main.png"></p><p>主要功能如下：</p><ol><li><p>展示 Electron 应用中所有开启的进程，包括主进程、普通的渲染进程、Service 进程(electron-re 引入)、ChildProcessPool 创建的子进程(electron-re 引入)。</p></li><li><p>进程列表中显示各个进程进程号、进程标识、父进程号、内存占用大小、CPU 占用百分比等，所有进程标识分为：main(主进程)、service(服务进程)、renderer(渲染进程)、node(进程池子进程)，点击表格头可以针对对某项进行递增/递减排序。</p></li><li><p>选中某个进程后可以 Kill 此进程、查看进程控制台 Console 数据、查看1分钟内进程 CPU/Memory 占用趋势，如果此进程是渲染进程的话还可以通过 <code>DevTools</code> 按钮一键打开内置调试工具。</p></li><li><p>ChildProcessPool 创建的子进程暂不支持直接打开 DevTools 进行调试，不过由于创建子进程时添加了 <code>--inspect</code> 参数，可以使用 chrome 的 <code>chrome://inspect</code> 进行远程调试。</p></li><li><p>点击 <code>Signals</code> 按钮可以查看 <code>MessageChannel</code> 工具的请求发送日志，包括简单的请求参数、请求名、请求返回数据等。</p></li></ol><h4 id="功能：Kill-进程">功能：Kill 进程</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/kill.gif" alt="kill.gif"></p><h4 id="功能：一键开启-DevTools">功能：一键开启 DevTools</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/devtools.gif" alt="devtools.gif"></p><h4 id="功能：查看进程日志">功能：查看进程日志</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/console.gif" alt="console.gif"></p><h4 id="功能：查看进程-CPU-Memory-占用趋势">功能：查看进程 CPU/Memory 占用趋势</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/trends.gif" alt="trends.gif"></p><h4 id="功能：查看-MessageChannel-请求发送日志">功能：查看 MessageChannel 请求发送日志</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" lazyload data-loading="/blogs/img/loading.gif" data-src="http://nojsja.gitee.io/static-resources/images/electron-re/signals.png" alt="console.gif"></p><h3 id="V-新特性：进程池负载均衡">V. 新特性：进程池负载均衡</h3><hr><blockquote><p>简化的初版实现</p></blockquote><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/electron-re/blob/master/src/libs/LoadBalancer/algorithm/index.js">&gt;&gt; 代码地址</a></p><h4 id="➣-关于负载均衡">➣ 关于负载均衡</h4><p>“ 负载均衡，英文名称为 Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。<br>负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。” – 《百度百科》</p><h4 id="➣-负载均衡策略说明">➣ 负载均衡策略说明</h4><p>之前的实现中，进程池创建好后，当使用 pool 发送请求时，采用两种方式处理请求发送策略：</p><ol><li><p>默认使用轮询策略选择一个子进程处理请求，只能保证基本的请求平均分配。</p></li><li><p>另一种使用情况是通过手动指定发送请求时的额外参数 id：<code>pool.send(channel, params, id)</code>，这样子让 <code>id</code> 相同的请求发送到同一个子进程上。一个适用情景就是：第一次我们向某个子进程发送请求，该子进程处理请求后在其运行时内存空间中存储了一些处理结果，之后某个情况下需要将之前那次请求产生的处理结果再次拿回主进程，这时候就需要使用 <code>id</code> 来区分请求。</p></li></ol><p>新版本引入了一些负载均衡策略，包括：</p><ul><li><strong>POLLING</strong> - 轮询：子进程轮流处理请求</li><li><strong>WEIGHTS</strong> - 权重：子进程根据设置的权重来处理请求</li><li><strong>RANDOM</strong> - 随机：子进程随机处理请求</li><li><strong>SPECIFY</strong> - 指定：子进程根据指定的进程 id 处理请求</li><li><strong>WEIGHTS_POLLING</strong> - 权重轮询：权重轮询策略与轮询策略类似，但是权重轮询策略会根据权重来计算子进程的轮询次数，从而稳定每个子进程的平均处理请求数量。</li><li><strong>WEIGHTS_RANDOM</strong> - 权重随机：权重随机策略与随机策略类似，但是权重随机策略会根据权重来计算子进程的随机次数，从而稳定每个子进程的平均处理请求数量。</li><li><strong>MINIMUM_CONNECTION</strong> - 最小连接数：选择子进程上具有最小连接活动数量的子进程处理请求。</li><li><strong>WEIGHTS_MINIMUM_CONNECTION</strong> - 权重最小连接数：权重最小连接数策略与最小连接数策略类似，不过各个子进程被选中的概率由连接数和权重共同决定。</li></ul><h4 id="➣-负载均衡策略的简易实现">➣ 负载均衡策略的简易实现</h4><p>参数说明：</p><ul><li>tasks：任务数组，一个示例：<code>[&#123;id: 11101, weight: 2&#125;, &#123;id: 11102, weight: 1&#125;]</code>。</li><li>currentIndex: 目前所处的任务索引，默认为 0，每次调用时会自动加 1，超出任务数组长度时会自动取模。</li><li>context：主进程参数上下文，用于动态更新当前任务索引和权重索引。</li><li>weightIndex：权重索引，用于权重策略，默认为 0，每次调用时会自动加 1，超出权重总和时会自动取模。</li><li>weightTotal：权重总和，用于权重策略相关计算。</li><li>connectionsMap：各个进程活动连接数的映射，用于最小连接数策略相关计算。</li></ul><h5 id="1-轮询策略-POLLING">1. 轮询策略(POLLING)</h5><blockquote><p>原理：索引值递增，每次调用时会自动加 1，超出任务数组长度时会自动取模，保证平均调用。<br>时间复杂度 O(n) = 1</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* polling algorithm */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, currentIndex, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tasks.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> task = tasks[currentIndex];</span><br><span class="line">  context.currentIndex ++;</span><br><span class="line">  context.currentIndex %= tasks.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> task || <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-权重策略-WEIGHTS">2. 权重策略(WEIGHTS)</h5><blockquote><p>原理：每个进程根据 (权重值 + (权重总和 * 随机因子)) 生成最终计算值，最终计算值中的最大值被命中。<br>时间复杂度 O(n) = n</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* weight algorithm */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, weightTotal, context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tasks.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> max = tasks[<span class="number">0</span>].weight, maxIndex = <span class="number">0</span>, sum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    sum = (tasks[i].weight || <span class="number">0</span>) + <span class="built_in">Math</span>.random() * weightTotal;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= max) &#123;</span><br><span class="line">      max = sum;</span><br><span class="line">      maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.weightIndex += <span class="number">1</span>;</span><br><span class="line">  context.weightIndex %= (weightTotal + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tasks[maxIndex];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-随机策略-RANDOM">3. 随机策略(RANDOM)</h5><blockquote><p>原理：随机函数在 [0, length) 中任意选取一个索引即可<br>时间复杂度 O(n) = 1</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* random algorithm */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> length = tasks.length;</span><br><span class="line">  <span class="keyword">const</span> target = tasks[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * length)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target || <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-权重轮询策略-WEIGHTS-POLLING">4. 权重轮询策略(WEIGHTS_POLLING)</h5><blockquote><p>原理：类似轮询策略，不过轮询的区间为：[最小权重值, 权重总和]，根据各项权重累加值进行命中区间计算。每次调用时权重索引会自动加 1，超出权重总和时会自动取模。<br>时间复杂度 O(n) = n</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* weights polling */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, weightIndex, weightTotal, context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tasks.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> weight = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> task;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    weight += tasks[i].weight || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weight &gt;= weightIndex) &#123;</span><br><span class="line">      task = tasks[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.weightIndex += <span class="number">1</span>;</span><br><span class="line">  context.weightIndex %= (weightTotal + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-权重随机策略-WEIGHTS-RANDOM">5. 权重随机策略(WEIGHTS_RANDOM)</h5><blockquote><p>原理：由 (权重总和 * 随机因子) 产生计算值，将各项权重值与其相减，第一个不大于零的最终值即被命中。<br>时间复杂度 O(n) = n</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* weights random algorithm */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, weightTotal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task;</span><br><span class="line">  <span class="keyword">let</span> weight = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * weightTotal);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    weight -= tasks[i].weight || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      task = tasks[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> task || <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="6-最小连接数策略-MINIMUM-CONNECTION">6. 最小连接数策略(MINIMUM_CONNECTION)</h5><blockquote><p>原理：直接选择当前连接数最小的项即可。<br>时间复杂度 O(n) = n</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* minimum connections algorithm */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, connectionsMap=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tasks.length &lt; <span class="number">2</span>) <span class="keyword">return</span> tasks[<span class="number">0</span>] || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> min = connectionsMap[tasks[<span class="number">0</span>].id];</span><br><span class="line">  <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> con = connectionsMap[tasks[i].id] || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (con &lt;= min) &#123;</span><br><span class="line">      min = con;</span><br><span class="line">      minIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tasks[minIndex] || <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-权重最小连接数-WEIGHTS-MINIMUM-CONNECTION">7. 权重最小连接数(WEIGHTS_MINIMUM_CONNECTION)</h5><blockquote><p>原理：权重 + ( 随机因子 * 权重总和 ) + ( 连接数占比 * 权重总和 ) 三个因子，计算出最终值，根据最终值的大小进行比较，最小值所代表项即被命中。<br>时间复杂度 O(n) = n</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* weights minimum connections algorithm */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tasks, weightTotal, connectionsMap, context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tasks.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> min = tasks[<span class="number">0</span>].weight, minIndex = <span class="number">0</span>, sum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> connectionsTotal = tasks.reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    total += (connectionsMap[cur.id] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// algorithm: (weight + connections&#x27;weight) + random factor</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    sum =</span><br><span class="line">      (tasks[i].weight || <span class="number">0</span>) + (<span class="built_in">Math</span>.random() * weightTotal) +</span><br><span class="line">      (( (connectionsMap[tasks[i].id] || <span class="number">0</span>) * weightTotal ) / connectionsTotal);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= min) &#123;</span><br><span class="line">      min = sum;</span><br><span class="line">      minIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.weightIndex += <span class="number">1</span>;</span><br><span class="line">  context.weightIndex %= (weightTotal + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tasks[minIndex];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="➣-负载均衡器的实现">➣ 负载均衡器的实现</h4><p>代码都不复杂，有几点需要说明：</p><ol><li><strong>params</strong> 对象保存了用于各种策略计算的一些参数，比如权重索引、权重总和、连接数、CPU/Memory占用等等。</li><li><strong>scheduler</strong> 对象用于调用各种策略进行计算，<code>scheduler.calculate()</code> 会返回一个命中的进程 id。</li><li><strong>targets</strong> 即所有用于计算的目标进程，不过其中仅存放了目标进程 pid 和 其权重 weight：<code>[&#123;id: [pid], weight: [number]&#125;, ...]</code>。</li><li><strong>algorithm</strong> 为特定的负载均衡策略，默认值为轮询策略。</li><li><strong>ProcessManager.on(‘refresh’, this.refreshParams)</strong>，负载均衡器通过监听 <code>ProcessManager</code> 的 refresh 事件来定时更新各个进程的计算参数。<code>ProcessManager</code> 中有一个定时器，每隔一段时间就会采集一次各个被监听的进程的资源占用情况，并携带采集数据触发一次 refresh 事件。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CONSTS = <span class="built_in">require</span>(<span class="string">&quot;./consts&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> Scheduler = <span class="built_in">require</span>(<span class="string">&quot;./scheduler&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  RANDOM,</span><br><span class="line">  POLLING,</span><br><span class="line">  WEIGHTS,</span><br><span class="line">  SPECIFY,</span><br><span class="line">  WEIGHTS_RANDOM,</span><br><span class="line">  WEIGHTS_POLLING,</span><br><span class="line">  MINIMUM_CONNECTION,</span><br><span class="line">  WEIGHTS_MINIMUM_CONNECTION,</span><br><span class="line">&#125; = CONSTS;</span><br><span class="line"><span class="keyword">const</span> ProcessManager = <span class="built_in">require</span>(<span class="string">&#x27;../ProcessManager&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load Balance Instance */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Object&#125;</span> </span>options [ options object ]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Array &#125;</span> </span>options.targets [ targets for load balancing calculation: [&#123;id: 1, weight: 1&#125;, &#123;id: 2, weight: 2&#125;] ]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>options.algorithm [ strategies for load balancing calculation : RANDOM | POLLING | WEIGHTS | SPECIFY | WEIGHTS_RANDOM | WEIGHTS_POLLING | MINIMUM_CONNECTION | WEIGHTS_MINIMUM_CONNECTION]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.targets = options.targets;</span><br><span class="line">    <span class="built_in">this</span>.algorithm = options.algorithm || POLLING;</span><br><span class="line">    <span class="built_in">this</span>.params = &#123; <span class="comment">// data for algorithm</span></span><br><span class="line">      <span class="attr">currentIndex</span>: <span class="number">0</span>, <span class="comment">// index</span></span><br><span class="line">      <span class="attr">weightIndex</span>: <span class="number">0</span>, <span class="comment">// index for weight alogrithm</span></span><br><span class="line">      <span class="attr">weightTotal</span>: <span class="number">0</span>, <span class="comment">// total weight</span></span><br><span class="line">      <span class="attr">connectionsMap</span>: &#123;&#125;, <span class="comment">// connections of each target</span></span><br><span class="line">      <span class="attr">cpuOccupancyMap</span>: &#123;&#125;, <span class="comment">// cpu occupancy of each target</span></span><br><span class="line">      <span class="attr">memoryOccupancyMap</span>: &#123;&#125;, <span class="comment">// cpu occupancy of each target</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.scheduler = <span class="keyword">new</span> Scheduler(<span class="built_in">this</span>.algorithm);</span><br><span class="line">    <span class="built_in">this</span>.memoParams = <span class="built_in">this</span>.memorizedParams();</span><br><span class="line">    <span class="built_in">this</span>.calculateWeightIndex();</span><br><span class="line">    ProcessManager.on(<span class="string">&#x27;refresh&#x27;</span>, <span class="built_in">this</span>.refreshParams);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* params formatter */</span></span><br><span class="line">  memorizedParams = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      [RANDOM]: <span class="function">() =&gt;</span> [],</span><br><span class="line">      [POLLING]: <span class="function">() =&gt;</span> [<span class="built_in">this</span>.params.currentIndex, <span class="built_in">this</span>.params],</span><br><span class="line">      [WEIGHTS]: <span class="function">() =&gt;</span> [<span class="built_in">this</span>.params.weightTotal, <span class="built_in">this</span>.params],</span><br><span class="line">      [SPECIFY]: <span class="function">(<span class="params">id</span>) =&gt;</span> [id],</span><br><span class="line">      [WEIGHTS_RANDOM]: <span class="function">() =&gt;</span> [<span class="built_in">this</span>.params.weightTotal],</span><br><span class="line">      [WEIGHTS_POLLING]: <span class="function">() =&gt;</span> [<span class="built_in">this</span>.params.weightIndex, <span class="built_in">this</span>.params.weightTotal, <span class="built_in">this</span>.params],</span><br><span class="line">      [MINIMUM_CONNECTION]: <span class="function">() =&gt;</span> [<span class="built_in">this</span>.params.connectionsMap],</span><br><span class="line">      [WEIGHTS_MINIMUM_CONNECTION]: <span class="function">() =&gt;</span> [<span class="built_in">this</span>.params.weightTotal, <span class="built_in">this</span>.params.connectionsMap, <span class="built_in">this</span>.params],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* refresh params data */</span></span><br><span class="line">  refreshParams = <span class="function">(<span class="params">pidMap</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pick one task from queue */</span></span><br><span class="line">  pickOne = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.scheduler.calculate(</span><br><span class="line">      <span class="built_in">this</span>.targets, <span class="built_in">this</span>.memoParams[<span class="built_in">this</span>.algorithm](...params)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* pick multi task from queue */</span></span><br><span class="line">  pickMulti = <span class="function">(<span class="params">count = <span class="number">1</span>, ...params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(count).fill().map(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="built_in">this</span>.pickOne(...params)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* calculate weight */</span></span><br><span class="line">  calculateWeightIndex = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.params.weightTotal = <span class="built_in">this</span>.targets.reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> total + (cur.weight || <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.params.weightIndex &gt; <span class="built_in">this</span>.params.weightTotal) &#123;</span><br><span class="line">      <span class="built_in">this</span>.params.weightIndex = <span class="built_in">this</span>.params.weightTotal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* calculate index */</span></span><br><span class="line">  calculateIndex = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.params.currentIndex &gt;= <span class="built_in">this</span>.targets.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.params.currentIndex = (ths.params.currentIndex - <span class="number">1</span> &gt;= <span class="number">0</span>) ? (<span class="built_in">this</span>.params.currentIndex - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* clean data of a task or all task */</span></span><br><span class="line">  clean = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* add a task */</span></span><br><span class="line">  add = <span class="function">(<span class="params">task</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* remove target from queue */</span></span><br><span class="line">  del = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* wipe queue and data */</span></span><br><span class="line">  wipe = <span class="function">() =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* update calculate params */</span></span><br><span class="line">  updateParams = <span class="function">(<span class="params">object</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.entries(object).map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> <span class="built_in">this</span>.params) &#123;</span><br><span class="line">        <span class="built_in">this</span>.params[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* reset targets */</span></span><br><span class="line">  setTargets = <span class="function">(<span class="params">targets</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* change algorithm strategy */</span></span><br><span class="line">  setAlgorithm = <span class="function">(<span class="params">algorithm</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Object</span>.assign(LoadBalancer, &#123; <span class="attr">ALGORITHM</span>: CONSTS &#125;);</span><br></pre></td></tr></table></figure><h4 id="➣-进程池配合-LoadBalancer-来实现负载均衡">➣ 进程池配合 LoadBalancer 来实现负载均衡</h4><p>有几点需要说明：</p><ol><li>当我们使用 <code>pool.send('channel', params)</code> 时，pool 内部 <code>getForkedFromPool()</code> 函数会被调用，函数从进程池中选择一个进程来执行任务，如果子进程数未达到最大设定数，则优先创建一个子进程来处理请求。</li><li>子进程 创建/销毁/退出 时需要同步更新 <code>LoadBalancer</code> 中监听的 <code>targets</code>，否则已被销毁的进程 pid 可能会在执行负载均衡策略计算后被返回。</li><li><code>ForkedProcess</code> 是一个装饰器类，封装了 <code>child_process.fork</code> 逻辑，为其增加了一些额外功能，如：进程睡眠、唤醒、绑定事件、发送请求等基本方法。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ForkedProcess = <span class="built_in">require</span>(<span class="string">&#x27;./ForkedProcess&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ProcessLifeCycle = <span class="built_in">require</span>(<span class="string">&#x27;../ProcessLifeCycle.class&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ProcessManager = <span class="built_in">require</span>(<span class="string">&#x27;../ProcessManager/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; defaultLifecycle &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../ProcessLifeCycle.class&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> LoadBalancer = <span class="built_in">require</span>(<span class="string">&#x27;../LoadBalancer&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> &#123; inspectStartIndex &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../conf/global.json&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; getRandomString, removeForkedFromPool, convertForkedToMap, isValidValue &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../utils&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; UPDATE_CONNECTIONS_SIGNAL &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../consts&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultStrategy = LoadBalancer.ALGORITHM.POLLING;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProcessPool</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    path, max=<span class="number">6</span>, cwd, env=&#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    weights=[], <span class="regexp">//</span> weights <span class="keyword">of</span> processes, the length is equal to max</span></span></span><br><span class="line"><span class="params"><span class="function">    strategy=defaultStrategy,</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.cwd = cwd || _path.dirname(path);</span><br><span class="line">    <span class="built_in">this</span>.env = &#123;</span><br><span class="line">      ...process.env,</span><br><span class="line">      ...env</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.callbacks = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.pidMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="built_in">this</span>.callbacksMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="built_in">this</span>.connectionsMap=&#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.forked = [];</span><br><span class="line">    <span class="built_in">this</span>.connectionsTimer = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.forkedMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.forkedPath = path;</span><br><span class="line">    <span class="built_in">this</span>.forkIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.maxInstance = max;</span><br><span class="line">    <span class="built_in">this</span>.weights = <span class="keyword">new</span> <span class="built_in">Array</span>(max).fill().map(</span><br><span class="line">      <span class="function">(<span class="params">_, i</span>) =&gt;</span> (isValidValue(weights[i]) ? weights[i] : <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">this</span>.LB = <span class="keyword">new</span> LoadBalancer(&#123;</span><br><span class="line">      <span class="attr">algorithm</span>: strategy,</span><br><span class="line">      <span class="attr">targets</span>: [],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.initEvents();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* -------------- internal -------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* init events */</span></span><br><span class="line">  initEvents = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// process exit</span></span><br><span class="line">    <span class="built_in">this</span>.on(<span class="string">&#x27;forked_exit&#x27;</span>, <span class="function">(<span class="params">pid</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onForkedDisconnect(pid);</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * onForkedCreate [triggered when a process instance created]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;[String]&#125;</span> </span>pid [process pid]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  onForkedCreate = <span class="function">(<span class="params">forked</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pidsValue = <span class="built_in">this</span>.forked.map(<span class="function"><span class="params">f</span> =&gt;</span> f.pid);</span><br><span class="line">    <span class="keyword">const</span> length = <span class="built_in">this</span>.forked.length;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.LB.add(&#123;</span><br><span class="line">      <span class="attr">id</span>: forked.pid,</span><br><span class="line">      <span class="attr">weight</span>: <span class="built_in">this</span>.weights[length - <span class="number">1</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    ProcessManager.listen(pidsValue, <span class="string">&#x27;node&#x27;</span>, <span class="built_in">this</span>.forkedPath);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * onForkedDisconnect [triggered when a process instance disconnect]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;[String]&#125;</span> </span>pid [process pid]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   onForkedDisconnect = <span class="function">(<span class="params">pid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> length = <span class="built_in">this</span>.forked.length;</span><br><span class="line"></span><br><span class="line">    removeForkedFromPool(<span class="built_in">this</span>.forked, pid, <span class="built_in">this</span>.pidMap);</span><br><span class="line">    <span class="built_in">this</span>.LB.del(&#123;</span><br><span class="line">      <span class="attr">id</span>: pid,</span><br><span class="line">      <span class="attr">weight</span>: <span class="built_in">this</span>.weights[length - <span class="number">1</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    ProcessManager.unlisten([pid]);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get a process instance from the pool */</span></span><br><span class="line">  getForkedFromPool = <span class="function">(<span class="params">id=<span class="string">&quot;default&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> forked;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.pidMap.get(id)) &#123;</span><br><span class="line">      <span class="comment">// create new process and put it into the pool</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.forked.length &lt; <span class="built_in">this</span>.maxInstance) &#123;</span><br><span class="line">        inspectStartIndex ++;</span><br><span class="line">        forked = <span class="keyword">new</span> ForkedProcess(</span><br><span class="line">          <span class="built_in">this</span>,</span><br><span class="line">          <span class="built_in">this</span>.forkedPath,</span><br><span class="line">          <span class="built_in">this</span>.env.NODE_ENV === <span class="string">&quot;development&quot;</span> ? [<span class="string">`--inspect=<span class="subst">$&#123;inspectStartIndex&#125;</span>`</span>] : [],</span><br><span class="line">          &#123; <span class="attr">cwd</span>: <span class="built_in">this</span>.cwd, <span class="attr">env</span>: &#123; ...this.env, id &#125;, <span class="attr">stdio</span>: <span class="string">&#x27;pipe&#x27;</span> &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">this</span>.forked.push(forked);</span><br><span class="line">        <span class="built_in">this</span>.onForkedCreate(forked);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// get a process from the pool based on load balancing strategy</span></span><br><span class="line">        forked = <span class="built_in">this</span>.forkedMap[<span class="built_in">this</span>.LB.pickOne().id];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (id !== <span class="string">&#x27;default&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.pidMap.set(id, forked.pid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// pick a special process from the pool</span></span><br><span class="line">      forked = <span class="built_in">this</span>.forkedMap[<span class="built_in">this</span>.pidMap.get(id)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!forked) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Get forked process from pool failed! the process pid: <span class="subst">$&#123;<span class="built_in">this</span>.pidMap.get(id)&#125;</span>.`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forked;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* -------------- caller -------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * send [Send request to a process]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param  <span class="type">&#123;[String]&#125;</span> </span>taskName [task name - necessary]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param  <span class="type">&#123;[Any]&#125;</span> </span>params [data passed to process - necessary]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param  <span class="type">&#123;[String]&#125;</span> </span>id [the unique id bound to a process instance - not necessary]</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;[Promise]&#125;</span> </span>[return a Promise instance]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  send = <span class="function">(<span class="params">taskName, params, givenId</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (givenId === <span class="string">&#x27;default&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;ChildProcessPool: Prohibit the use of this id value: [default] !&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = getRandomString();</span><br><span class="line">    <span class="keyword">const</span> forked = <span class="built_in">this</span>.getForkedFromPool(givenId);</span><br><span class="line">    <span class="built_in">this</span>.lifecycle.refresh([forked.pid]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks[id] = resolve;</span><br><span class="line">      forked.send(&#123;<span class="attr">action</span>: taskName, params, id &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ChildProcessPool;</span><br></pre></td></tr></table></figure><h3 id="VI-新特性：子进程智能启停">VI. 新特性：子进程智能启停</h3><hr><p>这个特性我也将其称为 <code>进程生命周期</code> (lifecycle)。</p><p>主要作用是：当子进程一段时间未被调用，则自动进入休眠状态，减少 CPU 占用 (减少内存占用很难)。进入休眠状态的时间可以和由创建者控制，默认为 10 min。当子进程进入休眠后，如果有新的请求到来并分发到该休眠的进程上，则会自动唤醒该进程并继续处理当前请求。一段时间闲置后，将会再次进入休眠状态。</p><h4 id="➣-使进程休眠的各种方式">➣ 使进程休眠的各种方式</h4><p>1）如果是让进程暂停的话，可以向进程发送 <code>SIGSTOP</code> 信号，发送 <code>SIGCONT</code> 信号可以恢复进程。</p><p>Node.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process.kill([pid], <span class="string">&quot;SIGSTOP&quot;</span>);</span><br><span class="line">process.kill([pid], <span class="string">&quot;SIGCONT&quot;</span>);</span><br></pre></td></tr></table></figure><p>Unix System (Windows 暂未测试):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -STOP [pid]</span><br><span class="line"><span class="built_in">kill</span> -CONT [pid]</span><br></pre></td></tr></table></figure><p>2）Node.js 新的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait">Atomic.wait</a> API 也可以做到编程控制。该方法会监听一个 Int32Array 对象的给定下标下的值，若值未发生改变，则一直等待(阻塞 event loop)，直到发生超时(由 ms 参数决定)。可以在主进程中操作这块共享数据，然后为子进程解除休眠锁定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nil = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="keyword">new</span> SharedArrayBuffer(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">const</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>).fill(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1e3</span>);</span><br><span class="line">Atomics.wait(nil, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">Number</span>(<span class="number">600e3</span>));</span><br></pre></td></tr></table></figure><h4 id="➣-生命周期-LifeCycle-的实现">➣ 生命周期 LifeCycle 的实现</h4><p>代码同样很简单，有几点需要说明：</p><ol><li><p>采用了 <code>标记清除法</code>，子进程触发请求时更新调用时间，同时使用定时器循环计算各个被监听子进程的 ( 当前时间 - 上次调用时间) 差值。如果有超过设定的时间的进程则发送 <code>sleep</code> 信号，同时携带所有进程 pid。</p></li><li><p>每个 <code>ChildProcessPool</code> 进程池实例都会拥有一个 <code>ProcessLifeCycle</code> 实例对象用于控制当前进程池中的进程的 休眠/唤醒。<code>ChildProcessPool</code> 会监听 <code>ProcessLifeCycle</code> 对象的 <code>sleep</code> 事件，拿到需要 sleep 的进程 pid 后调用 <code>ForkedProcess</code> 的 <code>sleep()</code> 方法使其睡眠。下个请求分发到该进程时，会自动唤醒该进程。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultLifecycle = &#123;</span><br><span class="line">  <span class="attr">expect</span>: <span class="number">600e3</span>, <span class="comment">// default timeout 10 minutes</span></span><br><span class="line">  <span class="attr">internal</span>: <span class="number">30e3</span> <span class="comment">// default loop check interval 30 seconds</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessLifeCycle</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      expect=defaultLifecycle.expect,</span><br><span class="line">      internal=defaultLifecycle.internal</span><br><span class="line">    &#125; = options;</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.internal = internal;</span><br><span class="line">    <span class="built_in">this</span>.expect = expect;</span><br><span class="line">    <span class="built_in">this</span>.params = &#123;</span><br><span class="line">      <span class="attr">activities</span>: <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* task check loop */</span></span><br><span class="line">  taskLoop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.timer) <span class="keyword">return</span> <span class="built_in">console</span>.warn(<span class="string">&#x27;ProcessLifeCycle: the task loop is already running&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> sleepTasks = [];</span><br><span class="line">      <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">const</span> &#123; activities &#125; = <span class="built_in">this</span>.params;</span><br><span class="line">      ([...activities.entries()]).map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (date - value &gt; <span class="built_in">this</span>.expect) &#123;</span><br><span class="line">          sleepTasks.push(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (sleepTasks.length) &#123;</span><br><span class="line">        <span class="comment">// this.unwatch(sleepTasks);</span></span><br><span class="line">        <span class="built_in">this</span>.emit(<span class="string">&#x27;sleep&#x27;</span>, sleepTasks);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="built_in">this</span>.internal);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* watch processes */</span></span><br><span class="line">  watch = <span class="function">(<span class="params">ids=[]</span>) =&gt;</span> &#123;</span><br><span class="line">    ids.forEach(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.params.activities.set(id, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unwatch processes */</span></span><br><span class="line">  unwatch = <span class="function">(<span class="params">ids=[]</span>) =&gt;</span> &#123;</span><br><span class="line">    ids.forEach(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.params.activities.delete(id);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* stop task check loop */</span></span><br><span class="line">  stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* start task check loop */</span></span><br><span class="line">  start = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.taskLoop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* refresh tasks */</span></span><br><span class="line">  refresh = <span class="function">(<span class="params">ids=[]</span>) =&gt;</span> &#123;</span><br><span class="line">    ids.forEach(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.params.activities.has(id)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.params.activities.set(id, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">`The task with id <span class="subst">$&#123;id&#125;</span> is not being watched.`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Object</span>.assign(ProcessLifeCycle, &#123; defaultLifecycle &#125;);</span><br></pre></td></tr></table></figure><h4 id="➣-进程互斥锁的雏形">➣ 进程互斥锁的雏形</h4><p>之前看文章时看到关于 API - <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait">Atomic.wait</a> 的一篇文章，Atomic 除了用于实现进程睡眠，也能基于它来理解进程互斥锁的实现原理。这里有个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/electron-re/blob/master/src/libs/AsyncLock.js">基本雏形</a>可以作为参考，相关文档可以参阅 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics">MDN</a>。</p><p>AsyncLock 对象需要在子进程中引入，创建 AsyncLock 的构造函数中有一个参数 <code>sab</code> 需要注意。这个参数是一个 <code>SharedArrayBuffer</code> 共享数据块，这个共享数据快需要在主进程创建，然后通过 IPC 通信发送到各个子进程，通常 IPC 通信会序列化一般的诸如 Object / Array 等数据，导致消息接受者和消息发送者拿到的不是同一个对象，但是经由 IPC 发送的 <code>SharedArrayBuffer</code> 对象却会指向同一个内存块。</p><p>在子进程中使用 <code>SharedArrayBuffer</code> 数据创建 AsyncLock 实例后，任意一个子进程对共享数据的修改都会导致其它进程内指向这块内存的 <code>SharedArrayBuffer</code> 数据内容变化，这就是我们使用它实现进程锁的基本要点。</p><p>先对 <code>Atomic</code> API 做个简单说明：</p><ul><li><strong>Atomics.compareExchange(typedArray, index, expectedValue, newValue)</strong>：Atomics.compareExchange() 静态方法会在数组的值与期望值相等的时候，将给定的替换值替换掉数组上的值，然后返回旧值。此原子操作保证在写上修改的值之前不会发生其他写操作。</li><li><strong>Atomics.waitAsync(typedArray, index, value[, timeout])</strong>：静态方法 Atomics.wait() 确保了一个在 Int32Array 数组中给定位置的值没有发生变化且仍然是给定的值时进程将会睡眠，直到被唤醒或超时。该方法返回一个字符串，值为&quot;ok&quot;, “not-equal”, 或 “timed-out” 之一。</li><li><strong>Atomics.notify(typedArray, index[, count])</strong>：静态方法 Atomics.notify() 唤醒指定数量的在等待队列中休眠的进程，不指定 count 时默认唤醒所有。</li></ul><p>AsyncLock 即异步锁，等待锁释放的时候不会阻塞主线程。主要关注 <code>executeAfterLocked()</code> 这个方法，调用该方法并传入回调函数，该回调函数会在锁被获取后执行，并且在执行完毕后自动释放锁。其中一步的关键就是 <code>tryGetLock()</code> 函数，它返回了一个 <code>Promise</code> 对象，因此我们等待锁释放的逻辑在微任务队列中执行而并不阻塞主线程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@name <span class="variable">AsyncLock</span></span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment">  *   Use it in child processes, mutex lock logic.</span></span><br><span class="line"><span class="comment">  *   First create SharedArrayBuffer in main process and transfer it to all child processes to control the lock.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncLock</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> INDEX = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> UNLOCKED = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> LOCKED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">sab</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sab = sab; <span class="comment">// data like this: const sab = new SharedArrayBuffer(16);</span></span><br><span class="line">    <span class="built_in">this</span>.i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(sab);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = Atomics.compareExchange(</span><br><span class="line">        <span class="built_in">this</span>.i32a, AsyncLock.INDEX,</span><br><span class="line">        AsyncLock.UNLOCKED, <span class="comment">// old</span></span><br><span class="line">        AsyncLock.LOCKED <span class="comment">// new</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (oldValue == AsyncLock.UNLOCKED) &#123; <span class="comment">// success</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Atomics.wait( <span class="comment">// wait</span></span><br><span class="line">        <span class="built_in">this</span>.i32a,</span><br><span class="line">        AsyncLock.INDEX,</span><br><span class="line">        AsyncLock.LOCKED <span class="comment">// expect</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">unlock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = Atomics.compareExchange(</span><br><span class="line">      <span class="built_in">this</span>.i32a, AsyncLock.INDEX,</span><br><span class="line">      AsyncLock.LOCKED,</span><br><span class="line">      AsyncLock.UNLOCKED</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (oldValue != AsyncLock.LOCKED) &#123; <span class="comment">// failed</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Tried to unlock while not holding the mutex&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Atomics.notify(<span class="built_in">this</span>.i32a, AsyncLock.INDEX, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * executeLocked [async function to acquired the lock and execute callback]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback [callback function]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="title">executeAfterLocked</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tryGetLock = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = Atomics.compareExchange(</span><br><span class="line">          <span class="built_in">this</span>.i32a,</span><br><span class="line">          AsyncLock.INDEX,</span><br><span class="line">          AsyncLock.UNLOCKED,</span><br><span class="line">          AsyncLock.LOCKED</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (oldValue == AsyncLock.UNLOCKED) &#123; <span class="comment">// success if AsyncLock.UNLOCKED</span></span><br><span class="line">          callback();</span><br><span class="line">          <span class="built_in">this</span>.unlock();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = Atomics.waitAsync( <span class="comment">// wait when AsyncLock.LOCKED</span></span><br><span class="line">          <span class="built_in">this</span>.i32a,</span><br><span class="line">          AsyncLock.INDEX,</span><br><span class="line">          AsyncLock.LOCKED</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">await</span> result.value; <span class="comment">// return a Promise, will not block the main thread</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryGetLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VII-存在的已知问题">VII. 存在的已知问题</h3><hr><ol><li><p>由于使用了 Electron 原生的 <code>remote</code> API，因此 <code>electron-re</code> 部分特性(Service 相关)不支持 Electron 14 以及以上版本(已经移除 remote)，正考虑近期使用第三方 <code>remote</code> 库进行替代兼容。</p></li><li><p>容错处理做的不够好，这一块会成为之后的重要优化点。</p></li><li><p>采集进程池中活动连接数时采用了&quot;调用计数&quot;的方式。这个处理方法不太好，准确性也不够高，但是目前还未想到更好的解决方法用于统计子进程中活跃的连接数。我觉得还是要从底层进行解决，比如：宏任务和微任务队列、V8 虚拟机、垃圾回收、Libuv 底层原理、Node 进程和线程原理…</p></li><li><p>暂时没在 windows 平台测试进程休眠功能，win 平台本身不支持进程信号，但是 Node 提供了模拟支持，但是具体表现还需测试。</p></li></ol><h3 id="VIII-Next-To-Do">VIII. Next To Do</h3><hr><ul class="contains-task-list"><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" checked type="checkbox"> 让 Service 支持代码更新后自动重启</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" checked type="checkbox"> 添加 ChildProcessPool 子进程调度逻辑</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" checked type="checkbox"> 优化 ChildProcessPool 多进程console输出</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" checked type="checkbox"> 添加可视化进程管理界面</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" checked type="checkbox"> 增强 ChildProcessPool 进程池功能</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" type="checkbox"> 增强 ProcessHost 事务中心功能</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" type="checkbox"> 子进程之间互斥锁逻辑的实现</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" type="checkbox"> 使用外部 remote 库以支持最新版本的 Electron</label></li><li class="task-list-item enabled"><label><input class="task-list-item-checkbox" type="checkbox"> <strong>Kill Bugs</strong> 🐛</label></li></ul><h3 id="IX-几个实际使用示例">IX. 几个实际使用示例</h3><hr><ol><li><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/electronux">electronux</a> - 我的一个Electron项目，使用了 <code>BrowserService/MessageChannel</code>，并且附带了<code>ChildProcessPool/ProcessHost</code>使用demo。</p></li><li><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/shadowsocks-electron">shadowsocks-electron</a> - 我的另一个Electron 跨平台桌面应用项目，使用 <code>electron-re</code> 进行调试开发，并且在生产环境下可以打开 <code>ProcessManager</code> UI 用于 CPU/Memory 资源占用监控和请求日志查看。</p></li><li><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/javascript-learning/tree/master/file-slice-upload">file-slice-upload</a> - 一个关于多文件分片并行上传的demo，使用了 <code>ChildProcessPool</code> and <code>ProcessHost</code>，基于 Electron@9.3.5开发。</p></li><li><p>也可直接查看 <code>index.test.js</code> 和 <code>test</code> 目录下的测试样例文件，包含了一些使用示例。</p></li><li><p>当然 github - <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja/electron-re">README</a> 也有相关说明项。</p></li></ol><span class="meta" id="headerViewCountWrapper"><span id="<Your/Path/Name>" class="leancloud_visitors" data-flag-title="Your Article Title"><em class="post-meta-item-text">⇸⇸ 阅读量：</em> <i class="leancloud-visitors-count">[ loading ]</i>⇷⇷</span></span><script>document.querySelector("#headerViewCountWrapper > .leancloud_visitors").id=decodeURIComponent(window.location.pathname)</script><hr style="margin-top:5px"><ul class="pager"><li class="next"><a href="/blogs/2021/11/29/adb1f235.html/" data-toggle="tooltip" data-placement="top" title="记一次 React hooks 组件开发和优化记录">Next Post &rarr;</a></li></ul><style type="text/css">.aplayer-container{text-align:center}.lds-roller-loading{display:inline-block;position:relative;width:80px;height:80px}.lds-roller-loading div{animation:lds-roller 1.2s cubic-bezier(.5,0,.5,1) infinite;transform-origin:40px 40px}.lds-roller-loading div:after{content:" ";display:block;position:absolute;width:7px;height:7px;border-radius:50%;background:#ff59ac;margin:-4px 0 0 -4px}.lds-roller-loading div:nth-child(1){animation-delay:-36ms}.lds-roller-loading div:nth-child(1):after{top:63px;left:63px}.lds-roller-loading div:nth-child(2){animation-delay:-72ms}.lds-roller-loading div:nth-child(2):after{top:68px;left:56px}.lds-roller-loading div:nth-child(3){animation-delay:-108ms}.lds-roller-loading div:nth-child(3):after{top:71px;left:48px}.lds-roller-loading div:nth-child(4){animation-delay:-144ms}.lds-roller-loading div:nth-child(4):after{top:72px;left:40px}.lds-roller-loading div:nth-child(5){animation-delay:-.18s}.lds-roller-loading div:nth-child(5):after{top:71px;left:32px}.lds-roller-loading div:nth-child(6){animation-delay:-216ms}.lds-roller-loading div:nth-child(6):after{top:68px;left:24px}.lds-roller-loading div:nth-child(7){animation-delay:-252ms}.lds-roller-loading div:nth-child(7):after{top:63px;left:17px}.lds-roller-loading div:nth-child(8){animation-delay:-288ms}.lds-roller-loading div:nth-child(8):after{top:56px;left:12px}@keyframes lds-roller{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.aplayer .aplayer-pic .aplayer-pause svg{top:0;left:0}.aplayer .aplayer-pic .aplayer-play svg{top:0;left:2px}</style><div class="aplayer-container"><div id="aplayer" class="lds-roller-loading" lazy-css-href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css" lazy-js-src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><script>(function(){var e,t=document.querySelector("#aplayer"),s=function(s,i){var r=[];s&&r.push(s),i&&r.push(i),r.forEach((function(s){async(s,(function(){/^.*.js$/.test(s)&&function(){e&&e.disconnect(),t.className="",t.innerHTML="";new APlayer({container:document.getElementById("aplayer"),theme:"#e9e9e9",audio:[{name:"存在信号",artist:"AcuticNotes",url:"http://nojsja.gitee.io/static-resources/audio/life-signal.mp3",cover:"http://nojsja.gitee.io/static-resources/audio/life-signal.jpg"},{name:"遺サレタ場所／斜光",artist:"岡部啓一",url:"http://nojsja.gitee.io/static-resources/audio/%E6%96%9C%E5%85%89.mp3",cover:"http://nojsja.gitee.io/static-resources/audio/%E6%96%9C%E5%85%89.jpg"}]})}()}),/^.*.css$/.test(s)?"link":"script")}))};if(window.IntersectionObserver)(e=new IntersectionObserver((function(t){t.forEach((function(t){if(t.isIntersecting){e.unobserve(t.target);var i=t.target.getAttribute("lazy-css-href"),r=t.target.getAttribute("lazy-js-src");s(i,r)}}))}))).observe(t);else{var i=t.getAttribute("lazy-css-href"),r=t.getAttribute("lazy-js-src");s(i,r)}}).bind(window)()</script><hr><div id="vcomments"></div><script>(function(){function e(){async("/blogs/js/Valine.min.js",(function(){new Valine({el:"#vcomments",appId:"wUKKBx8BRzGaNfhgdg2UKtub-MdYXbMMI",appKey:"MAwYM4KlW5YJ3q06qwnUScBr",visitor:!0})}))}if(window.IntersectionObserver){var n=new IntersectionObserver((function(i){i.forEach((function(i){i.isIntersecting&&(n.unobserve(i.target),n.disconnect(),e())}))}));n.observe(document.querySelector("#headerViewCountWrapper"))}else e()}).bind(window)()</script></div><aside id="sidebar"><div id="toc" class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Contents"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Contents</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#I-%E5%89%8D%E8%A8%80"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">I. 前言</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#II-electron-re%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">II. electron-re架构图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#III-electron-re-%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">III. electron-re 可以用来做什么？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-%E7%94%A8%E4%BA%8EElectron%E5%BA%94%E7%94%A8"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">1. 用于Electron应用</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-%E7%94%A8%E4%BA%8E-Electron-Nodejs-%E5%BA%94%E7%94%A8"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">2. 用于 Electron&#x2F;Nodejs 应用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#IV-UI-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">IV. UI 功能介绍</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%BB%E7%95%8C%E9%9D%A2"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">主界面</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9AKill-%E8%BF%9B%E7%A8%8B"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">功能：Kill 进程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF-DevTools"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">功能：一键开启 DevTools</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%97%A5%E5%BF%97"><span class="toc-nav-number">5.4.</span> <span class="toc-nav-text">功能：查看进程日志</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-CPU-Memory-%E5%8D%A0%E7%94%A8%E8%B6%8B%E5%8A%BF"><span class="toc-nav-number">5.5.</span> <span class="toc-nav-text">功能：查看进程 CPU&#x2F;Memory 占用趋势</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%9F%A5%E7%9C%8B-MessageChannel-%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E6%97%A5%E5%BF%97"><span class="toc-nav-number">5.6.</span> <span class="toc-nav-text">功能：查看 MessageChannel 请求发送日志</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#V-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">V. 新特性：进程池负载均衡</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E5%85%B3%E4%BA%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">➣ 关于负载均衡</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E8%AF%B4%E6%98%8E"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">➣ 负载均衡策略说明</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0"><span class="toc-nav-number">6.3.</span> <span class="toc-nav-text">➣ 负载均衡策略的简易实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#1-%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5-POLLING"><span class="toc-nav-number">6.3.1.</span> <span class="toc-nav-text">1. 轮询策略(POLLING)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-%E6%9D%83%E9%87%8D%E7%AD%96%E7%95%A5-WEIGHTS"><span class="toc-nav-number">6.3.2.</span> <span class="toc-nav-text">2. 权重策略(WEIGHTS)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5-RANDOM"><span class="toc-nav-number">6.3.3.</span> <span class="toc-nav-text">3. 随机策略(RANDOM)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-%E6%9D%83%E9%87%8D%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5-WEIGHTS-POLLING"><span class="toc-nav-number">6.3.4.</span> <span class="toc-nav-text">4. 权重轮询策略(WEIGHTS_POLLING)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5-WEIGHTS-RANDOM"><span class="toc-nav-number">6.3.5.</span> <span class="toc-nav-text">5. 权重随机策略(WEIGHTS_RANDOM)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#6-%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%AD%96%E7%95%A5-MINIMUM-CONNECTION"><span class="toc-nav-number">6.3.6.</span> <span class="toc-nav-text">6. 最小连接数策略(MINIMUM_CONNECTION)</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#7-%E6%9D%83%E9%87%8D%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0-WEIGHTS-MINIMUM-CONNECTION"><span class="toc-nav-number">6.3.7.</span> <span class="toc-nav-text">7. 权重最小连接数(WEIGHTS_MINIMUM_CONNECTION)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-nav-number">6.4.</span> <span class="toc-nav-text">➣ 负载均衡器的实现</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E8%BF%9B%E7%A8%8B%E6%B1%A0%E9%85%8D%E5%90%88-LoadBalancer-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-nav-number">6.5.</span> <span class="toc-nav-text">➣ 进程池配合 LoadBalancer 来实现负载均衡</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#VI-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%99%BA%E8%83%BD%E5%90%AF%E5%81%9C"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">VI. 新特性：子进程智能启停</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E4%BD%BF%E8%BF%9B%E7%A8%8B%E4%BC%91%E7%9C%A0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">➣ 使进程休眠的各种方式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-LifeCycle-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">➣ 生命周期 LifeCycle 的实现</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E2%9E%A3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E9%9B%8F%E5%BD%A2"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text">➣ 进程互斥锁的雏形</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#VII-%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">VII. 存在的已知问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#VIII-Next-To-Do"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">VIII. Next To Do</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#IX-%E5%87%A0%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">IX. 几个实际使用示例</span></a></li></ol></div></aside></div></div></article><script>async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",(function(){anchors.options={visible:"hover",placement:"left",icon:"ℬ"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")}))</script><script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="/blogs/js/anchor.nojsja.js"></script><style>#websiteModal .modal-body{display:flex;align-items:center;justify-content:center;margin:auto;text-align:center;width:100%;height:100%}#websiteModal .modal-body img{max-width:100%;height:auto}</style><script>$(document).ready((function(){$(document).on("click","img",(function(o){if($(this).hasClass("click-disable"))o&&o.stopPropagation();else{o&&o.stopPropagation();var a=$(this).clone();$("#websiteModal").modal("show"),a.addClass("click-disable"),$("#websiteModal .modal-body").html(a)}})).on("click",".modal-body",(function(){$("#websiteModal").modal("hide")}))}))</script><div class="modal fade" id="websiteModal" tabindex="-1" role="dialog" aria-labelledby="websiteModalTitle" aria-hidden="true"><div class="modal-body"></div></div><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nojsja"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; nojsja 2021</p></div></div></div></footer><script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.2/js/bootstrap.min.js"></script><script src="/blogs/js/widgets.js"></script><script>async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",(function(){var c=document.querySelector("nav");c&&FastClick.attach(c)}))</script><script type="text/javascript">var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/blogs/"+search_path;searchFunc(path,"local-search-input","local-search-result")</script><script src="/blogs/js/busuanzi.pure.mini.js" defer async></script><a id="rocket" href="#top"></a><script type="text/javascript" src="/blogs/js/totop.js" async></script><script>(function(){function t(t){return document.querySelectorAll(t)}if(window.hexoLoadingImages=window.hexoLoadingImages||{},window.IntersectionObserver){var e=new IntersectionObserver((function(t){t.forEach((function(t){if(t.isIntersecting){e.unobserve(t.target);var n=new Image,o="_img_"+Math.random();window.hexoLoadingImages[o]=n,n.onload=function(){t.target.src=t.target.getAttribute("data-src"),window.hexoLoadingImages[o]=null},n.onerror=function(){window.hexoLoadingImages[o]=null},t.target.src=t.target.getAttribute("data-loading"),n.src=t.target.getAttribute("data-src")}}))}));t("img[lazyload]").forEach((function(t){e.observe(t)}))}else t("img[lazyload]").forEach((function(t){t.src=t.getAttribute("data-src")}))}).bind(window)()</script></body></html>